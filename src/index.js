// Generated by LiveScript 1.5.0
/**
 * @package   Ronion
 * @author    Nazar Mokrynskyi <nazar@mokrynskyi.com>
 * @copyright Copyright (c) 2017, Nazar Mokrynskyi
 * @license   MIT License, see license.txt
 */
(function(){
  var asyncEventer, randombytes, COMMAND_CREATE_REQUEST, COMMAND_CREATE_RESPONSE, COMMAND_EXTEND_REQUEST, COMMAND_EXTEND_RESPONSE, COMMAND_DESTROY, COMMAND_DATA;
  asyncEventer = require('async-eventer');
  randombytes = require('randombytes');
  module.exports = {
    Router: Router
  };
  COMMAND_CREATE_REQUEST = 1;
  COMMAND_CREATE_RESPONSE = 2;
  COMMAND_EXTEND_REQUEST = 3;
  COMMAND_EXTEND_RESPONSE = 4;
  COMMAND_DESTROY = 5;
  COMMAND_DATA = 6;
  /**
   * @param {Uint8Array} array
   *
   * @return {string}
   */
  function to_string(array){
    return array.join('');
  }
  /**
   * @param {Uint8Array} packet
   *
   * @return {array} [version: number, segment_id: Uint8Array]
   */
  function parse_packet_header(packet){
    return [packet[0], packet.subarray(1, 2)];
  }
  /**
   * @param {Uint8Array} packet_data
   *
   * @return {number[]} [command, command_data_length]
   */
  function parse_packet_data_header(packet_data){
    return [packet_data[0], packet_data[0] * 256 + packet_data[1]];
  }
  /**
   * @param {Uint8Array} packet_data
   *
   * @return {array} [command: number, command_data: Uint8Array]
   */
  function parse_packet_data_plaintext(packet_data){
    var ref$, command, command_data_length;
    ref$ = parse_packet_data_header(packet_data), command = ref$[0], command_data_length = ref$[1];
    return [command, packet_data.slice(3, 3 + command_data_length)];
  }
  /**
   * @param {number}		packet_size
   * @param {number}		version
   * @param {Uint8Array}	segment_id
   * @param {number}		command
   * @param {Uint8Array}	command_data
   *
   * @return {Uint8Array}
   */
  function generate_packet_plaintext(packet_size, version, segment_id, command, command_data){
    var packet_data_header, x$, packet, bytes_written, random_bytes_padding_length;
    packet_data_header = generate_packet_data_header(command, command_data.length);
    x$ = packet = new Uint8Array(packet_size);
    x$.set([version]);
    x$.set(segment_id, 1);
    x$.set(packet_data_header, 3);
    x$.set(command_data, 6);
    bytes_written = 6 + command_data.length;
    random_bytes_padding_length = packet_size - bytes_written;
    if (random_bytes_padding_length) {
      packet.set(randombytes(random_bytes_padding_length), bytes_written);
    }
    return packet;
  }
  /**
   * @param {number}	command
   * @param {number}	command_data_length
   *
   * @return {Uint8Array}
   */
  function generate_packet_data_header(command, command_data_length){
    var lsb, msb;
    lsb = command_data_length % 256;
    msb = (command_data_length - lsb) / 256;
    return Uint8Array.of(command, msb, lsb);
  }
  /**
   * @param {Uint8Array}	address
   * @param {Uint8Array}	segment_id
   *
   * @return {string}
   */
  function compute_source_id(address, segment_id){
    return to_string(address) + to_string(segment_id);
  }
  /**
   * @constructor
   *
   * @param {number}	version			0..255
   * @param {number}	packet_size
   * @param {number}	address_length
   * @param {number}	mac_length
   */
  function Router(version, packet_size, address_length, mac_length){
    if (!(this instanceof Router)) {
      return new Router(version, packet_size, address_length, mac_length);
    }
    asyncEventer.call(this);
    this._version = version;
    this._packet_size = packet_size;
    this._address_length = address_length;
    this._mac_length = mac_length;
    this._established_segments = new Set;
  }
  Router.prototype = {
    /**
     * Must be called when new packet appear
     *
     * @param {Uint8Array}	address	Address (in application-specific format) where packet came from
     * @param {Uint8Array}	packet	Packet
     */
    process_packet: function(address, packet){
      var ref$, version, segment_id, source_id, packet_data;
      if (packet.length !== this._packet_size) {
        return;
      }
      ref$ = parse_packet_header(packet), version = ref$[0], segment_id = ref$[1];
      if (version !== this._version) {
        return;
      }
      source_id = compute_source_id(address, segment_id);
      packet_data = packet.subarray(3);
      if (!this._established_segments.has(source_id)) {
        this._process_packet_data_plaintext(address, segment_id, packet_data);
      } else {
        this._process_packet_data_encrypted(source_id, packet_data);
      }
    }
    /**
     * Must be called when new segment is established with node that has specified address
     *
     * @param {Uint8Array}	address
     * @param {Uint8Array}	segment_id
     */,
    confirm_established_segment: function(address, segment_id){
      var source_id;
      source_id = compute_source_id(address, segment_id);
      this._established_segments.add(source_id);
    }
    /**
     * Must be called in order to start new routing path, sends CREATE_REQUEST
     *
     * @param {Uint8Array}	address		Node at which to start routing path
     * @param {Uint8Array}	segment_id	Unique segment ID for specified address
     * @param {Uint8Array}	data
     */,
    create_request: function(address, segment_id, data){
      var packet;
      packet = generate_packet_plaintext(this._packet_size, this._version, segment_id, COMMAND_CREATE_REQUEST, data);
      this.fire('send', {
        address: address,
        packet: packet
      });
    }
    /**
     * Must be called in order to respond to CREATE_RESPONSE
     *
     * @param {Uint8Array}	address		Node from which CREATE_REQUEST come from
     * @param {Uint8Array}	segment_id	Same segment ID as in CREATE_REQUEST
     * @param {Uint8Array}	data
     */,
    create_response: function(address, segment_id, data){
      var packet;
      packet = generate_packet_plaintext(this._packet_size, this._version, segment_id, COMMAND_CREATE_RESPONSE, data);
      this.fire('send', {
        address: address,
        packet: packet
      });
    }
    /**
     * @param {Uint8Array}	address
     * @param {Uint8Array}	segment_id
     * @param {Uint8Array}	packet_data
     */,
    _process_packet_data_plaintext: function(address, segment_id, packet_data){
      var ref$, command, command_data;
      ref$ = parse_packet_data_plaintext(packet_data), command = ref$[0], command_data = ref$[1];
      switch (command) {
      case COMMAND_CREATE_REQUEST:
        this.fire('create_request', {
          address: address,
          segment_id: segment_id,
          data: command_data
        });
        break;
      case COMMAND_CREATE_RESPONSE:
        this.fire('create_response', {
          address: address,
          segment_id: segment_id,
          data: command_data
        });
      }
    }
    /**
     * @param {Uint8Array}	address
     * @param {Uint8Array}	segment_id
     * @param {Uint8Array}	packet_data
     */,
    _process_packet_data_encrypted: function(address, segment_id, packet_data){
      var packet_data_header_encrypted, data, this$ = this;
      packet_data_header_encrypted = packet_data.slice(0, 3 + this._mac_length);
      data = {
        address: address,
        segment_id: segment_id,
        ciphertext: packet_data_header_encrypted,
        plaintext: null
      };
      this.fire('decrypt', data).then(function(){
        var plaintext, ref$, command, command_data_length, command_data_encrypted;
        plaintext = data.plaintext;
        if (!(plaintext instanceof Uint8Array) && plaintext.length !== 3) {
          return;
        }
        ref$ = parse_packet_data_header(plaintext), command = ref$[0], command_data_length = ref$[1];
        command_data_encrypted = packet_data.slice(packet_data_header_encrypted.length, packet_data_header_encrypted.length + command_data_length);
        data = {
          address: address,
          segment_id: segment_id,
          ciphertext: command_data_encrypted,
          plaintext: null
        };
        this$.fire('decrypt', data).then(function(){
          var plaintext;
          plaintext = data.plaintext;
          if (!(plaintext instanceof Uint8Array) && plaintext.length !== command_data_length) {
            return;
          }
        });
      });
    }
  };
  Router.prototype = Object.assign(Object.create(asyncEventer.prototype), Router.prototype);
  Object.defineProperty(Router.prototype, 'constructor', {
    enumerable: false,
    value: Router
  });
}).call(this);
